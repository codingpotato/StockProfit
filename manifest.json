{"makefile":"CXXFLAGS += -I. -std=c++11 -Wall -Wextra -Werror\nCXXFLAGS += -fsanitize=undefined -fno-sanitize-recover=undefined\nCXXFLAGS += -fsanitize=address -fno-omit-frame-pointer\n\nGTEST_LIBS = -lgtest -lgtest_main -pthread\n\nHPP_FILES = $(wildcard *.hpp)\nCOMPILED_HPP_FILES = $(patsubst %.hpp,%.compiled_hpp,$(HPP_FILES))\nCPP_FILES = $(wildcard *.cpp)\n\n.PHONY: test.output\ntest.output: test makefile\n\t@./$< --gtest_shuffle\n\ntest: makefile $(CPP_FILES) $(COMPILED_HPP_FILES)\n\t@$(CXX) $(CXXFLAGS) -O $(CPP_FILES) $(GTEST_LIBS) -o $@\n\n# This rule ensures header files build in their own right.\n# The quality of header files is important because header files\n# are #included from other files and thus have a large span\n# of influence (unlike .cpp files which are not #included)\n\n%.compiled_hpp: %.hpp\n\t@$(CXX) -x c++ $(CXXFLAGS) -c -o $@ $<","cyber-dojo.sh":"export CXX=clang++\nmake --always-make\n\n","output":"Running main() from gtest_main.cc\nNote: Randomizing tests' orders with a seed of 88374 .\n[==========] Running 7 tests from 1 test case.\n[----------] Global test environment set-up.\n[----------] 7 tests from StockProfit\n[ RUN      ] StockProfit.Get_max_profit_after_buy_for_empty_prices\nASAN:SIGSEGV\n=================================================================\n==16==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000004 (pc 0x00000051a55a bp 0x7ffee2dfc070 sp 0x7ffee2dfbf80 T0)\n    #0 0x51a559 in StockProfit::getMaxProfitsAfterBuy() (/sandbox/test+0x51a559)\n    #1 0x51c8b3 in StockProfit_Get_max_profit_after_buy_for_empty_prices_Test::TestBody() (/sandbox/test+0x51c8b3)\n    #2 0x53e34b in void testing::internal::HandleSehExceptionsInMethodIfSupported<testing::Test, void>(testing::Test*, void (testing::Test::*)(), char const*) (/sandbox/test+0x53e34b)\n    #3 0x5393eb in void testing::internal::HandleExceptionsInMethodIfSupported<testing::Test, void>(testing::Test*, void (testing::Test::*)(), char const*) (/sandbox/test+0x5393eb)\n    #4 0x52659a in testing::Test::Run() (/sandbox/test+0x52659a)\n    #5 0x526d15 in testing::TestInfo::Run() (/sandbox/test+0x526d15)\n    #6 0x5272d5 in testing::TestCase::Run() (/sandbox/test+0x5272d5)\n    #7 0x52bf2f in testing::internal::UnitTestImpl::RunAllTests() (/sandbox/test+0x52bf2f)\n    #8 0x53f895 in bool testing::internal::HandleSehExceptionsInMethodIfSupported<testing::internal::UnitTestImpl, bool>(testing::internal::UnitTestImpl*, bool (testing::internal::UnitTestImpl::*)(), char const*) (/sandbox/test+0x53f895)\n    #9 0x53a2d7 in bool testing::internal::HandleExceptionsInMethodIfSupported<testing::internal::UnitTestImpl, bool>(testing::internal::UnitTestImpl*, bool (testing::internal::UnitTestImpl::*)(), char const*) (/sandbox/test+0x53a2d7)\n    #10 0x52ad2c in testing::UnitTest::Run() (/sandbox/test+0x52ad2c)\n    #11 0x548afa in main (/sandbox/test+0x548afa)\n    #12 0x2b4ce09c5ec4 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21ec4)\n    #13 0x46d859 in _start (/sandbox/test+0x46d859)\n\nAddressSanitizer can not provide additional info.\nSUMMARY: AddressSanitizer: SEGV ??:0 StockProfit::getMaxProfitsAfterBuy()\n==16==ABORTING\nmake: *** [test.output] Error 1\n","StockProfit.cpp":"#include \"StockProfit.hpp\"\n\nStockProfit::StockProfit(vector<int> prices)\n    : prices_(prices) {\n}\n\nvector<int> StockProfit::getMaxProfitsAfterBuy() {\n    vector<int> maxProfitsAfterBuy;\n    int maxProfits[2];\n    maxProfits[0] = 0;\n    maxProfits[1] = prices_[1] - prices_[0];\n    for (unsigned int i = 0; i < prices_.size(); ++i) {\n        int profit = -prices_[i];\n        if (i > 1) {\n            profit += maxProfits[i - 2];\n        }\n        maxProfitsAfterBuy.push_back(profit);\n    }\n    return maxProfitsAfterBuy;\n}\n\nvector<vector<int>> StockProfit::getTransactions() {\n    vector<vector<int>> transactions;\n    if (prices_.size() == 1) {\n        vector<int> transaction;\n        transaction.push_back(PASS);\n        transactions.push_back(transaction);\n    } else if (prices_.size() == 2) {\n        vector<int> transaction;\n        transaction.push_back(BUY);\n        transaction.push_back(SELL);\n        transactions.push_back(transaction);\n    }\n    return transactions;\n}\n","StockProfit.hpp":"#ifndef STOCK_PROFIT_INCLUDED\n#define STOCK_PROFIT_INCLUDED\n\n#include <vector>\n\nusing namespace std;\n\n\nenum Transaction {\n    PASS, BUY, SELL, COOLDOWN\n};\n\n\nclass StockProfit {\n\npublic:\n    StockProfit(vector<int> prices);\n\n    vector<int> getMaxProfitsAfterBuy();\n    vector<vector<int>> getTransactions();\n\nprivate:\n    vector<int> prices_;\n\n};\n\n#endif","StockProfit.tests.cpp":"#include \"StockProfit.hpp\"\n#include <gtest/gtest.h>\n\nusing namespace ::testing;\n\nTEST(StockProfit, Empty_prices) {\n    vector<int> prices;\n    vector<vector<int>> expectTransactions;\n\n    StockProfit stockProfit(prices);\n    ASSERT_EQ(expectTransactions, stockProfit.getTransactions());\n}\n\nTEST(StockProfit, Get_max_profit_after_buy_for_empty_prices) {\n    vector<int> prices;\n    vector<int> expectMaxProfitsAfterBuy;\n\n    StockProfit stockProfit(prices);\n    ASSERT_EQ(expectMaxProfitsAfterBuy,\n        stockProfit.getMaxProfitsAfterBuy());\n}\n\nTEST(StockProfit, One_day_prices) {\n    int priceValues[] = {1};\n    vector<int> prices(priceValues, priceValues + 1);\n    vector<vector<int>> expectTransactions;\n    int transactionValues[] = {PASS};\n    expectTransactions.push_back(\n        vector<int>(transactionValues, transactionValues + 1));\n    \n    StockProfit stockProfit(prices);\n    ASSERT_EQ(expectTransactions, stockProfit.getTransactions());\n}\n\nTEST(StockProfit, Get_max_profit_after_buy_for_one_day_prices) {\n    int priceValues[] = {1};\n    vector<int> prices(priceValues, priceValues + 1);\n    int maxProfitsAfterBuyValues[] = {-1};\n    vector<int> expectMaxProfitsAfterBuy(\n        maxProfitsAfterBuyValues, maxProfitsAfterBuyValues + 1);\n\n    StockProfit stockProfit(prices);\n    ASSERT_EQ(expectMaxProfitsAfterBuy,\n        stockProfit.getMaxProfitsAfterBuy());\n}\n\nTEST(StockProfit, Two_day_prices) {\n    int pricesLength = 2;\n    int priceValues[] = {1, 2};\n    vector<int> prices(priceValues, priceValues + pricesLength);\n    vector<vector<int>> expectTransactions;\n    int transactionValues[] = {BUY, SELL};\n    expectTransactions.push_back(\n        vector<int>(transactionValues, transactionValues + pricesLength));\n    \n    StockProfit stockProfit(prices);\n    ASSERT_EQ(expectTransactions, stockProfit.getTransactions());\n}\n\nTEST(StockProfit, Get_max_profit_after_buy_for_two_day_prices) {\n    int pricesLength = 2;\n    int priceValues[] = {1, 2};\n    vector<int> prices(priceValues, priceValues + pricesLength);\n    int maxProfitsAfterBuyValues[] = {-1, -2};\n    vector<int> expectMaxProfitsAfterBuy(\n        maxProfitsAfterBuyValues, maxProfitsAfterBuyValues + pricesLength);\n\n    StockProfit stockProfit(prices);\n    ASSERT_EQ(expectMaxProfitsAfterBuy,\n        stockProfit.getMaxProfitsAfterBuy());\n}\n\nTEST(StockProfit, Get_max_profit_after_buy_for_four_day_prices) {\n    int priceValues[] = {1, 2, 3, 4};\n    int pricesLength = sizeof(priceValues) / sizeof(int);\n    vector<int> prices(priceValues, priceValues + pricesLength);\n    int maxProfitsAfterBuyValues[] = {-1, -2, -3, -3};\n    vector<int> expectMaxProfitsAfterBuy(\n        maxProfitsAfterBuyValues, maxProfitsAfterBuyValues + pricesLength);\n\n    StockProfit stockProfit(prices);\n    ASSERT_EQ(expectMaxProfitsAfterBuy,\n        stockProfit.getMaxProfitsAfterBuy());\n}\n"}